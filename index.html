<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kitchen Dashboard</title>
<script src="config.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
padding: 20px;
min-height: 100vh;
transition: background-color 0.5s, color 0.5s;
}
body.light-theme {
background: #f5f7fa;
color: #2c3e50;
}
body.dark-theme {
background: #1a1a2e;
color: white;
}
.container { max-width: 1800px; margin: 0 auto; }
.header {
display: grid;
grid-template-columns: 1fr 2fr 1fr;
gap: 20px;
margin-bottom: 24px;
padding-bottom: 24px;
}
.light-theme .header {
border-bottom: 2px solid rgba(0,0,0,0.1);
}
.dark-theme .header {
border-bottom: 2px solid rgba(255,255,255,0.1);
}
.time-section {
text-align: left;
display: flex;
flex-direction: column;
justify-content: center;
}
.time { font-size: 56px; font-weight: 300; margin-bottom: 5px; }
.date { font-size: 18px; opacity: 0.8; line-height: 1.4; }
.photo-section {
position: relative;
border-radius: 16px;
overflow: hidden;
box-shadow: 0 4px 12px rgba(0,0,0,0.15);
aspect-ratio: 16/9;
max-height: 450px;
}
.light-theme .photo-section {
background: rgba(0,0,0,0.05);
border: 1px solid rgba(0,0,0,0.08);
}
.dark-theme .photo-section {
background: rgba(255,255,255,0.05);
border: 1px solid rgba(255,255,255,0.1);
}
.photo-frame {
position: relative;
width: 100%;
height: 100%;
}
.photo-image {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
object-fit: cover;
opacity: 0;
transition: opacity 1s ease-in-out;
}
.photo-image.active {
opacity: 1;
z-index: 1;
}
.photo-placeholder {
display: flex;
align-items: center;
justify-content: center;
width: 100%;
height: 100%;
font-size: 64px;
opacity: 0.3;
}
.weather-card {
border-radius: 16px;
padding: 24px;
box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
.light-theme .weather-card {
background: white;
border: 1px solid rgba(0,0,0,0.08);
}
.dark-theme .weather-card {
background: rgba(255, 255, 255, 0.05);
border: 1px solid rgba(255,255,255,0.1);
}
.weather-card h2 {
font-size: 18px;
margin-bottom: 16px;
opacity: 0.9;
padding-bottom: 12px;
font-weight: 600;
}
.light-theme .weather-card h2 {
border-bottom: 1px solid rgba(0,0,0,0.1);
}
.dark-theme .weather-card h2 {
border-bottom: 1px solid rgba(255,255,255,0.1);
}
.weather-current {
display: flex;
align-items: center;
gap: 15px;
margin-bottom: 16px;
}
.weather-icon { font-size: 42px; }
.temp { font-size: 36px; font-weight: 300; }
.weather-details { font-size: 13px; opacity: 0.8; line-height: 1.8; }
.forecast {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 10px;
margin-top: 16px;
}
.forecast-day {
padding: 10px;
border-radius: 8px;
text-align: center;
font-size: 12px;
}
.light-theme .forecast-day {
background: rgba(0,0,0,0.03);
}
.dark-theme .forecast-day {
background: rgba(255,255,255,0.05);
}
.forecast-day .day { font-weight: 600; margin-bottom: 6px; }
.forecast-day .icon { font-size: 24px; margin: 6px 0; }
.forecast-day .temp { font-size: 16px; font-weight: 600; margin: 6px 0; }
.forecast-day .rain { opacity: 0.7; font-size: 11px; margin-top: 4px; }
.calendar {
border-radius: 16px;
padding: 24px;
margin-bottom: 24px;
box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
.light-theme .calendar {
background: white;
border: 1px solid rgba(0,0,0,0.08);
}
.dark-theme .calendar {
background: rgba(255, 255, 255, 0.05);
border: 1px solid rgba(255,255,255,0.1);
}
.calendar h2 {
font-size: 22px;
margin-bottom: 20px;
opacity: 0.9;
padding-bottom: 12px;
font-weight: 600;
}
.light-theme .calendar h2 {
border-bottom: 1px solid rgba(0,0,0,0.1);
}
.dark-theme .calendar h2 {
border-bottom: 1px solid rgba(255,255,255,0.1);
}
.calendar-grid {
display: grid;
grid-template-columns: repeat(7, 1fr);
gap: 6px;
}
.calendar-header {
text-align: center;
font-weight: 600;
font-size: 12px;
padding: 12px 5px;
opacity: 0.7;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.calendar-day {
min-height: 85px;
padding: 8px;
border-radius: 8px;
position: relative;
}
.light-theme .calendar-day {
background: rgba(0,0,0,0.02);
}
.dark-theme .calendar-day {
background: rgba(255,255,255,0.03);
}
.calendar-day.other-month {
opacity: 0.3;
}
.light-theme .calendar-day.today {
background: rgba(77, 166, 255, 0.15);
border: 1px solid #4da6ff;
}
.dark-theme .calendar-day.today {
background: rgba(77, 166, 255, 0.2);
border: 1px solid #4da6ff;
}
.day-number {
font-size: 14px;
font-weight: 600;
margin-bottom: 6px;
}
.day-events {
font-size: 10px;
line-height: 1.5;
}
.day-event {
padding: 3px 5px;
margin-bottom: 3px;
border-radius: 4px;
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
}
.light-theme .day-event {
background: rgba(77, 166, 255, 0.2);
color: #1a5490;
}
.dark-theme .day-event {
background: rgba(77, 166, 255, 0.3);
}
.day-event.more-indicator {
font-weight: 600;
text-align: center;
opacity: 0.8;
}
.light-theme .day-event.more-indicator {
background: rgba(77, 166, 255, 0.15);
}
.dark-theme .day-event.more-indicator {
background: rgba(77, 166, 255, 0.2);
}
.tasks-section {
border-radius: 16px;
padding: 24px;
box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
.light-theme .tasks-section {
background: white;
border: 1px solid rgba(0,0,0,0.08);
}
.dark-theme .tasks-section {
background: rgba(255, 255, 255, 0.05);
border: 1px solid rgba(255,255,255,0.1);
}
.tasks-section h2 {
font-size: 22px;
margin-bottom: 20px;
opacity: 0.9;
padding-bottom: 12px;
font-weight: 600;
}
.light-theme .tasks-section h2 {
border-bottom: 1px solid rgba(0,0,0,0.1);
}
.dark-theme .tasks-section h2 {
border-bottom: 1px solid rgba(255,255,255,0.1);
}
.kanban-board {
display: flex;
gap: 20px;
overflow-x: auto;
padding-bottom: 10px;
}
.kanban-column {
min-width: 300px;
flex: 1;
border-radius: 12px;
padding: 16px;
min-height: 200px;
}
.light-theme .kanban-column {
background: rgba(0,0,0,0.02);
}
.dark-theme .kanban-column {
background: rgba(255,255,255,0.03);
}
.light-theme .kanban-column.drag-over {
background: rgba(77, 166, 255, 0.15);
border: 2px dashed #4da6ff;
}
.dark-theme .kanban-column.drag-over {
background: rgba(77, 166, 255, 0.2);
border: 2px dashed #4da6ff;
}
.kanban-column h3 {
font-size: 16px;
margin-bottom: 16px;
opacity: 0.9;
color: #4da6ff;
font-weight: 600;
}
.task-item {
border-radius: 8px;
padding: 14px;
margin-bottom: 10px;
font-size: 14px;
border-left: 3px solid #4da6ff;
cursor: grab;
user-select: none;
display: flex;
align-items: flex-start;
gap: 12px;
transition: all 0.2s;
}
.light-theme .task-item {
background: white;
box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.dark-theme .task-item {
background: rgba(255,255,255,0.05);
}
.light-theme .task-item:hover {
box-shadow: 0 2px 6px rgba(0,0,0,0.15);
transform: translateY(-1px);
}
.dark-theme .task-item:hover {
background: rgba(255,255,255,0.08);
}
.task-item:active {
cursor: grabbing;
}
.task-item.dragging {
opacity: 0.5;
}
.task-item.completing {
opacity: 0.3;
text-decoration: line-through;
}
.task-checkbox {
width: 20px;
height: 20px;
border-radius: 5px;
flex-shrink: 0;
margin-top: 1px;
cursor: pointer;
transition: all 0.2s;
}
.light-theme .task-checkbox {
border: 2px solid rgba(0,0,0,0.3);
}
.dark-theme .task-checkbox {
border: 2px solid rgba(255,255,255,0.4);
}
.task-checkbox:hover {
border-color: #4da6ff;
background: rgba(77, 166, 255, 0.1);
}
.task-text {
flex: 1;
line-height: 1.5;
}
@media (orientation: portrait) {
.header { grid-template-columns: 1fr; }
.photo-section { max-height: 350px; }
}
</style>
</head>
<body>
<div class="container">
<div class="header">
<div class="time-section">
<div class="time" id="time">00:00:00</div>
<div class="date" id="date">Loading...</div>
</div>
<div class="photo-section">
<div class="photo-frame" id="photoFrame">
<div class="photo-placeholder">üì∑</div>
</div>
</div>
<div class="weather-card">
<h2>üå§Ô∏è Weather</h2>
<div class="weather-current">
<div class="weather-icon" id="weatherIcon">‚òÄÔ∏è</div>
<div>
<div class="temp" id="temp">24¬∞C</div>
<div class="weather-details" id="weatherDetails">Loading...</div>
</div>
</div>
<div class="forecast" id="forecast">
<div class="forecast-day">
<div class="day">Loading...</div>
</div>
</div>
</div>
</div>
<div class="calendar">
<h2 id="calendarHeader">üìÖ January 2026</h2>
<div id="calendarEvents">
<div>Loading calendar...</div>
</div>
</div>
<div class="tasks-section">
<h2>‚úÖ Tasks</h2>
<div class="kanban-board" id="kanbanBoard">
<div class="kanban-column">
<h3>Loading...</h3>
</div>
</div>
</div>
</div>
<script>
let currentAccessToken = CONFIG.GOOGLE_TASKS.ACCESS_TOKEN;
let taskListsData = {};
let photoUrls = [];
let currentPhotoIndex = 0;

function getCompassDirection(degrees) {
const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
const index = Math.round(degrees / 22.5) % 16;
return directions[index];
}

function updateTheme() {
const now = new Date();
const hour = now.getHours();
// Light theme: 6am to 6pm, Dark theme: 6pm to 6am
const isDay = hour >= 6 && hour < 18;
document.body.className = isDay ? 'light-theme' : 'dark-theme';
}

function updateTime() {
const now = new Date();
document.getElementById('time').textContent = now.toLocaleTimeString('en-AU', {
hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true
});
document.getElementById('date').textContent = now.toLocaleDateString('en-AU', {
weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
});
updateTheme();
}

async function loadPhotos() {
if (typeof CONFIG === 'undefined' || !CONFIG.GOOGLE_PHOTOS) {
console.log('Google Photos not configured yet');
return;
}
try {
// Fetch album photos using Google Photos API
const albumId = CONFIG.GOOGLE_PHOTOS.ALBUM_ID;
const url = 'https://photoslibrary.googleapis.com/v1/mediaItems:search';
const response = await fetch(url, {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + CONFIG.GOOGLE_PHOTOS.ACCESS_TOKEN,
'Content-Type': 'application/json'
},
body: JSON.stringify({
albumId: albumId,
pageSize: 100
})
});

if (response.status === 401) {
console.error('Photos auth failed - need to refresh token');
return;
}

const data = await response.json();
if (data.mediaItems) {
// Get base URLs for all photos
photoUrls = data.mediaItems
.filter(item => item.mimeType && item.mimeType.startsWith('image/'))
.map(item => item.baseUrl);
console.log('Loaded ' + photoUrls.length + ' photos');
if (photoUrls.length > 0) {
showNextPhoto();
}
}
} catch (error) {
console.error('Photo fetch error:', error);
}
}

function showNextPhoto() {
if (photoUrls.length === 0) return;

const photoFrame = document.getElementById('photoFrame');
const currentImg = photoFrame.querySelector('.photo-image.active');
const newImg = document.createElement('img');
newImg.className = 'photo-image';
// Add size parameter optimized for landscape (16:9 aspect ratio)
newImg.src = photoUrls[currentPhotoIndex] + '=w1600-h900';
newImg.alt = 'Family photo';

newImg.onload = () => {
// Remove placeholder if it exists
const placeholder = photoFrame.querySelector('.photo-placeholder');
if (placeholder) {
placeholder.remove();
}

// Fade in new image
photoFrame.appendChild(newImg);
setTimeout(() => {
newImg.classList.add('active');
}, 50);

// Remove old image after transition
setTimeout(() => {
if (currentImg) {
currentImg.remove();
}
}, 1500);
};

// Move to next photo
currentPhotoIndex = (currentPhotoIndex + 1) % photoUrls.length;
}

async function updateWeather() {
if (typeof CONFIG === 'undefined') return;
try {
const url = 'https://api.weather.com/v2/pws/observations/current?stationId=' + CONFIG.WEATHER_UNDERGROUND.STATION_ID + '&format=json&units=m&apiKey=' + CONFIG.WEATHER_UNDERGROUND.API_KEY;
const response = await fetch(url);
const data = await response.json();
const obs = data.observations[0];

document.getElementById('temp').textContent = Math.round(obs.metric.temp) + '¬∞C';
const windDir = getCompassDirection(obs.winddir);
document.getElementById('weatherDetails').innerHTML =
'Humidity: ' + obs.humidity + '%<br>' +
'Wind: ' + Math.round(obs.metric.windSpeed) + ' km/h ' + windDir + ' (' + obs.winddir + '¬∞)<br>' +
'Rain today: ' + obs.metric.precipTotal + 'mm';

let icon = '‚òÄÔ∏è';
if (obs.solarRadiation < 200) icon = 'üåô';
else if (obs.humidity > 80) icon = 'üåßÔ∏è';
else if (obs.humidity > 60) icon = '‚õÖ';
document.getElementById('weatherIcon').textContent = icon;
} catch (error) {
console.error('Weather fetch error:', error);
}
}

async function updateForecast() {
if (typeof CONFIG === 'undefined' || !CONFIG.OPENWEATHERMAP) return;
try {
const url = 'https://api.openweathermap.org/data/2.5/forecast?lat=' + CONFIG.OPENWEATHERMAP.LAT + '&lon=' + CONFIG.OPENWEATHERMAP.LON + '&appid=' + CONFIG.OPENWEATHERMAP.API_KEY + '&units=metric';
const response = await fetch(url);
const data = await response.json();

const dailyForecasts = {};
data.list.forEach(item => {
const date = new Date(item.dt * 1000);
const dayKey = date.toLocaleDateString('en-AU', { weekday: 'short' });
const hour = date.getHours();

if (!dailyForecasts[dayKey] || Math.abs(hour - 12) < Math.abs(dailyForecasts[dayKey].hour - 12)) {
dailyForecasts[dayKey] = {
day: dayKey,
temp: Math.round(item.main.temp),
rain: item.rain ? item.rain['3h'] || 0 : 0,
pop: Math.round(item.pop * 100),
icon: item.weather[0].main,
hour: hour
};
}
});

const forecasts = Object.values(dailyForecasts).slice(0, 4);

const forecastDiv = document.getElementById('forecast');
forecastDiv.innerHTML = forecasts.map(f => {
let weatherIcon = '‚òÄÔ∏è';
if (f.icon === 'Rain') weatherIcon = 'üåßÔ∏è';
else if (f.icon === 'Clouds') weatherIcon = '‚òÅÔ∏è';
else if (f.icon === 'Clear') weatherIcon = '‚òÄÔ∏è';
else if (f.icon === 'Snow') weatherIcon = '‚ùÑÔ∏è';
else if (f.icon === 'Thunderstorm') weatherIcon = '‚õàÔ∏è';

return '<div class="forecast-day">' +
'<div class="day">' + f.day + '</div>' +
'<div class="icon">' + weatherIcon + '</div>' +
'<div class="temp">' + f.temp + '¬∞C</div>' +
'<div class="rain">' + f.pop + '% | ' + f.rain.toFixed(1) + 'mm</div>' +
'</div>';
}).join('');

} catch (error) {
console.error('Forecast fetch error:', error);
}
}

async function updateCalendar() {
if (typeof CONFIG === 'undefined' || !CONFIG.GOOGLE_CALENDAR) return;
try {
const now = new Date();
const year = now.getFullYear();
const month = now.getMonth();

// Update calendar header with current month
const monthName = now.toLocaleDateString('en-AU', { month: 'long', year: 'numeric' });
document.getElementById('calendarHeader').textContent = 'üìÖ ' + monthName;

const firstDay = new Date(year, month, 1);
const lastDay = new Date(year, month + 1, 0);

const timeMin = new Date(year, month, 1).toISOString();
const timeMax = new Date(year, month + 1, 0, 23, 59, 59).toISOString();

const allEvents = [];
for (const calendarId of CONFIG.GOOGLE_CALENDAR.CALENDAR_IDS) {
try {
const url = 'https://www.googleapis.com/calendar/v3/calendars/' + encodeURIComponent(calendarId) + '/events?key=' + CONFIG.GOOGLE_CALENDAR.API_KEY + '&timeMin=' + timeMin + '&timeMax=' + timeMax + '&singleEvents=true&orderBy=startTime&maxResults=100';
const response = await fetch(url);
const data = await response.json();

if (data.items) {
allEvents.push(...data.items);
}
} catch (err) {
console.error('Error fetching calendar ' + calendarId + ':', err);
}
}

const eventsByDate = {};
allEvents.forEach(event => {
const start = event.start.dateTime || event.start.date;
const date = new Date(start);
const dateKey = date.getFullYear() + '-' + date.getMonth() + '-' + date.getDate();

if (!eventsByDate[dateKey]) {
eventsByDate[dateKey] = [];
}

eventsByDate[dateKey].push({
title: event.summary || 'Untitled',
time: event.start.dateTime ? date.toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit', hour12: true }) : null
});
});

const calendarDiv = document.getElementById('calendarEvents');
let html = '<div class="calendar-grid">';

const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
dayNames.forEach(day => {
html += '<div class="calendar-header">' + day + '</div>';
});

const firstDayOfWeek = firstDay.getDay();

for (let i = 0; i < firstDayOfWeek; i++) {
const prevDate = new Date(year, month, -(firstDayOfWeek - i - 1));
html += '<div class="calendar-day other-month"><div class="day-number">' + prevDate.getDate() + '</div></div>';
}

for (let day = 1; day <= lastDay.getDate(); day++) {
const date = new Date(year, month, day);
const dateKey = year + '-' + month + '-' + day;
const isToday = date.toDateString() === now.toDateString();
const events = eventsByDate[dateKey] || [];

html += '<div class="calendar-day ' + (isToday ? 'today' : '') + '">';
html += '<div class="day-number">' + day + '</div>';
html += '<div class="day-events">';

events.slice(0, 3).forEach(event => {
const timeStr = event.time ? event.time + ' ' : '';
html += '<div class="day-event">' + timeStr + event.title + '</div>';
});

if (events.length > 3) {
html += '<div class="day-event more-indicator">+' + (events.length - 3) + ' more</div>';
}

html += '</div></div>';
}

const totalCells = firstDayOfWeek + lastDay.getDate();
const remainingCells = 7 - (totalCells % 7);
if (remainingCells < 7) {
for (let i = 1; i <= remainingCells; i++) {
html += '<div class="calendar-day other-month"><div class="day-number">' + i + '</div></div>';
}
}

html += '</div>';
calendarDiv.innerHTML = html;

} catch (error) {
console.error('Calendar fetch error:', error);
document.getElementById('calendarEvents').innerHTML = '<div>Error loading calendar</div>';
}
}

async function refreshAccessToken() {
try {
const response = await fetch('https://oauth2.googleapis.com/token', {
method: 'POST',
headers: {
'Content-Type': 'application/x-www-form-urlencoded',
},
body: new URLSearchParams({
client_id: CONFIG.GOOGLE_TASKS.CLIENT_ID,
client_secret: CONFIG.GOOGLE_TASKS.CLIENT_SECRET,
refresh_token: CONFIG.GOOGLE_TASKS.REFRESH_TOKEN,
grant_type: 'refresh_token'
})
});

const data = await response.json();
if (data.access_token) {
currentAccessToken = data.access_token;
return true;
}
return false;
} catch (error) {
console.error('Token refresh error:', error);
return false;
}
}

async function completeTask(taskId, listId, taskElement) {
try {
taskElement.classList.add('completing');

const completeUrl = 'https://www.googleapis.com/tasks/v1/lists/' + listId + '/tasks/' + taskId;
const response = await fetch(completeUrl, {
method: 'PATCH',
headers: {
'Authorization': 'Bearer ' + currentAccessToken,
'Content-Type': 'application/json'
},
body: JSON.stringify({
status: 'completed'
})
});

if (response.status === 401) {
await refreshAccessToken();
return await completeTask(taskId, listId, taskElement);
}

if (response.ok) {
setTimeout(() => {
taskElement.remove();
}, 300);
}
} catch (error) {
console.error('Complete task error:', error);
taskElement.classList.remove('completing');
}
}

async function moveTask(taskId, fromListId, toListId) {
try {
const taskData = taskListsData[fromListId].tasks.find(t => t.id === taskId);

const deleteUrl = 'https://www.googleapis.com/tasks/v1/lists/' + fromListId + '/tasks/' + taskId;
const deleteResponse = await fetch(deleteUrl, {
method: 'DELETE',
headers: {
'Authorization': 'Bearer ' + currentAccessToken
}
});

if (deleteResponse.status === 401) {
await refreshAccessToken();
return await moveTask(taskId, fromListId, toListId);
}

const createUrl = 'https://www.googleapis.com/tasks/v1/lists/' + toListId + '/tasks';
const createResponse = await fetch(createUrl, {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + currentAccessToken,
'Content-Type': 'application/json'
},
body: JSON.stringify({
title: taskData.title,
notes: taskData.notes || ''
})
});

if (createResponse.ok) {
await updateTasks();
}
} catch (error) {
console.error('Move task error:', error);
}
}

async function updateTasks() {
if (typeof CONFIG === 'undefined' || !CONFIG.GOOGLE_TASKS) return;
try {
const listsUrl = 'https://www.googleapis.com/tasks/v1/users/@me/lists';
const listsResponse = await fetch(listsUrl, {
headers: {
'Authorization': 'Bearer ' + currentAccessToken
}
});

if (listsResponse.status === 401) {
const refreshed = await refreshAccessToken();
if (refreshed) {
return await updateTasks();
} else {
throw new Error('Token refresh failed');
}
}

const listsData = await listsResponse.json();

if (!listsData.items) {
document.getElementById('kanbanBoard').innerHTML = '<div class="kanban-column"><h3>No task lists found</h3></div>';
return;
}

const wantedLists = listsData.items.filter(list =>
CONFIG.GOOGLE_TASKS.TASK_LISTS.includes(list.title)
);

taskListsData = {};
const kanbanHTML = [];

for (const list of wantedLists) {
try {
const tasksUrl = 'https://www.googleapis.com/tasks/v1/lists/' + list.id + '/tasks?maxResults=20';
const tasksResponse = await fetch(tasksUrl, {
headers: {
'Authorization': 'Bearer ' + currentAccessToken
}
});
const tasksData = await tasksResponse.json();

const tasks = tasksData.items || [];
const incompleteTasks = tasks.filter(task => task.status !== 'completed');

taskListsData[list.id] = { title: list.title, tasks: incompleteTasks };

let tasksHTML = '';
if (incompleteTasks.length === 0) {
tasksHTML = '<div style="opacity: 0.5; font-size: 13px;">No tasks</div>';
} else {
tasksHTML = incompleteTasks.map(task => {
return '<div class="task-item" draggable="true" data-task-id="' + task.id + '" data-list-id="' + list.id + '">' +
'<div class="task-checkbox" data-task-task-id="' + task.id + '" data-list-id="' + list.id + '"></div>' +
'<div class="task-text">' + task.title + '</div>' +
'</div>';
}).join('');
}

kanbanHTML.push(
'<div class="kanban-column" data-list-id="' + list.id + '">' +
'<h3>' + list.title + '</h3>' +
tasksHTML +
'</div>'
);
} catch (err) {
console.error('Error fetching tasks for ' + list.title + ':', err);
}
}

document.getElementById('kanbanBoard').innerHTML = kanbanHTML.join('');
setupDragAndDrop();
setupCheckboxes();

} catch (error) {
console.error('Tasks fetch error:', error);
document.getElementById('kanbanBoard').innerHTML = '<div class="kanban-column"><h3>Error loading tasks</h3></div>';
}
}

function setupCheckboxes() {
const checkboxes = document.querySelectorAll('.task-checkbox');
checkboxes.forEach(checkbox => {
checkbox.addEventListener('click', (e) => {
e.stopPropagation();
const taskId = checkbox.dataset.taskId;
const listId = checkbox.dataset.listId;
const taskElement = checkbox.closest('.task-item');
completeTask(taskId, listId, taskElement);
});
});
}

function setupDragAndDrop() {
const taskItems = document.querySelectorAll('.task-item');
const columns = document.querySelectorAll('.kanban-column');

taskItems.forEach(task => {
task.addEventListener('dragstart', (e) => {
task.classList.add('dragging');
e.dataTransfer.effectAllowed = 'move';
e.dataTransfer.setData('text/plain', task.dataset.taskId);
e.dataTransfer.setData('fromList', task.dataset.listId);
});

task.addEventListener('dragend', (e) => {
task.classList.remove('dragging');
});
});

columns.forEach(column => {
column.addEventListener('dragover', (e) => {
e.preventDefault();
column.classList.add('drag-over');
});

column.addEventListener('dragleave', (e) => {
column.classList.remove('drag-over');
});

column.addEventListener('drop', async (e) => {
e.preventDefault();
column.classList.remove('drag-over');

const taskId = e.dataTransfer.getData('text/plain');
const fromListId = e.dataTransfer.getData('fromList');
const toListId = column.dataset.listId;

if (fromListId !== toListId) {
await moveTask(taskId, fromListId, toListId);
}
});
});
}

// Initialize
updateTime();
setInterval(updateTime, 1000);

updateWeather();
updateForecast();
setInterval(updateWeather, 300000);
setInterval(updateForecast, 300000);

updateCalendar();
setInterval(updateCalendar, 300000);

updateTasks();
setInterval(updateTasks, 300000);

// Load and cycle photos
loadPhotos();
// Change photo every 45 seconds (45000ms) - adjust to your preference (30000 = 30sec, 60000 = 1min)
setInterval(showNextPhoto, 45000);

setTimeout(() => location.reload(), 60000);
</script>
</body>
</html>
