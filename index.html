<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kitchen Dashboard</title>
<script src="config.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
padding: 20px;
min-height: 100vh;
transition: background 0.8s ease, color 0.8s ease;
}
body.light-theme {
background: linear-gradient(to bottom, #e3f2fd 0%, #f5f7fa 50%, #fafafa 100%);
color: #2c3e50;
}
body.dark-theme {
background: linear-gradient(to bottom, #1a1a2e 0%, #16213e 50%, #0f0f1e 100%);
color: white;
}
.container { max-width: 1800px; margin: 0 auto; }
.header {
display: grid;
grid-template-columns: 1fr 2fr 1fr;
gap: 20px;
margin-bottom: 24px;
padding-bottom: 24px;
}
.light-theme .header {
border-bottom: 2px solid rgba(0,0,0,0.1);
}
.dark-theme .header {
border-bottom: 2px solid rgba(255,255,255,0.1);
}
.time-section {
text-align: left;
display: flex;
flex-direction: column;
justify-content: center;
}
.time { font-size: 56px; font-weight: 300; margin-bottom: 5px; }
.date { font-size: 18px; opacity: 0.8; line-height: 1.4; }
.photo-section {
position: relative;
border-radius: 20px;
overflow: hidden;
box-shadow: 0 8px 24px rgba(0,0,0,0.15);
aspect-ratio: 16/9;
max-height: 450px;
}
.light-theme .photo-section {
background: linear-gradient(135deg, rgba(0,0,0,0.05) 0%, rgba(0,0,0,0.02) 100%);
border: 1px solid rgba(0,0,0,0.08);
}
.dark-theme .photo-section {
background: linear-gradient(135deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.03) 100%);
border: 1px solid rgba(255,255,255,0.1);
}
.photo-frame {
position: relative;
width: 100%;
height: 100%;
}
.photo-image {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
object-fit: cover;
opacity: 0;
transition: opacity 1s ease-in-out;
}
.photo-image.active {
opacity: 1;
z-index: 1;
}
.photo-placeholder {
display: flex;
align-items: center;
justify-content: center;
flex-direction: column;
width: 100%;
height: 100%;
font-size: 64px;
opacity: 0.3;
}
.photo-error {
font-size: 14px;
margin-top: 10px;
opacity: 0.6;
}
.weather-card {
border-radius: 20px;
padding: 24px;
box-shadow: 0 4px 12px rgba(0,0,0,0.1);
transition: all 0.3s ease;
}
.light-theme .weather-card {
background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
border: 1px solid rgba(0,0,0,0.08);
}
.dark-theme .weather-card {
background: linear-gradient(135deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.05) 100%);
border: 1px solid rgba(255,255,255,0.1);
}
.weather-card h2 {
font-size: 18px;
margin-bottom: 16px;
opacity: 0.9;
padding-bottom: 12px;
font-weight: 600;
}
.light-theme .weather-card h2 {
border-bottom: 1px solid rgba(0,0,0,0.1);
}
.dark-theme .weather-card h2 {
border-bottom: 1px solid rgba(255,255,255,0.1);
}
.weather-current {
display: flex;
align-items: center;
gap: 15px;
margin-bottom: 16px;
}
.weather-icon { font-size: 42px; }
.temp-section { flex: 1; }
.temp { font-size: 36px; font-weight: 300; }
.feels-like { font-size: 14px; opacity: 0.7; margin-top: 4px; }
.weather-details { font-size: 13px; opacity: 0.8; line-height: 1.8; }
.sun-times {
display: flex;
gap: 20px;
margin-top: 12px;
padding-top: 12px;
font-size: 13px;
opacity: 0.8;
}
.light-theme .sun-times {
border-top: 1px solid rgba(0,0,0,0.08);
}
.dark-theme .sun-times {
border-top: 1px solid rgba(255,255,255,0.08);
}
.sun-time { display: flex; align-items: center; gap: 6px; }
.forecast {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 10px;
margin-top: 16px;
}
.forecast-day {
padding: 10px;
border-radius: 12px;
text-align: center;
font-size: 12px;
transition: all 0.2s ease;
}
.light-theme .forecast-day {
background: rgba(0,0,0,0.03);
}
.dark-theme .forecast-day {
background: rgba(255,255,255,0.05);
}
.forecast-day:hover {
transform: translateY(-2px);
}
.light-theme .forecast-day:hover {
background: rgba(0,0,0,0.05);
}
.dark-theme .forecast-day:hover {
background: rgba(255,255,255,0.08);
}
.forecast-day .day { font-weight: 600; margin-bottom: 6px; }
.forecast-day .icon { font-size: 24px; margin: 6px 0; }
.forecast-day .temp { font-size: 16px; font-weight: 600; margin: 6px 0; }
.forecast-day .rain { opacity: 0.7; font-size: 11px; margin-top: 4px; }
.calendar {
border-radius: 20px;
padding: 24px;
margin-bottom: 24px;
box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}
.light-theme .calendar {
background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
border: 1px solid rgba(0,0,0,0.08);
}
.dark-theme .calendar {
background: linear-gradient(135deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.05) 100%);
border: 1px solid rgba(255,255,255,0.1);
}
.calendar h2 {
font-size: 22px;
margin-bottom: 20px;
opacity: 0.9;
padding-bottom: 12px;
font-weight: 600;
}
.light-theme .calendar h2 {
border-bottom: 1px solid rgba(0,0,0,0.1);
}
.dark-theme .calendar h2 {
border-bottom: 1px solid rgba(255,255,255,0.1);
}
.calendar-grid {
display: grid;
grid-template-columns: repeat(7, 1fr);
gap: 6px;
}
.calendar-header {
text-align: center;
font-weight: 600;
font-size: 12px;
padding: 12px 5px;
opacity: 0.7;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.calendar-day {
min-height: 85px;
padding: 8px;
border-radius: 12px;
position: relative;
transition: all 0.2s ease;
}
.light-theme .calendar-day {
background: rgba(0,0,0,0.02);
}
.dark-theme .calendar-day {
background: rgba(255,255,255,0.03);
}
.calendar-day.other-month {
opacity: 0.3;
}
.calendar-day.past {
opacity: 0.4;
}
.light-theme .calendar-day.today {
background: linear-gradient(135deg, rgba(77, 166, 255, 0.2) 0%, rgba(77, 166, 255, 0.1) 100%);
border: 2px solid #4da6ff;
transform: scale(1.02);
}
.dark-theme .calendar-day.today {
background: linear-gradient(135deg, rgba(77, 166, 255, 0.25) 0%, rgba(77, 166, 255, 0.15) 100%);
border: 2px solid #4da6ff;
transform: scale(1.02);
}
.day-number {
font-size: 14px;
font-weight: 600;
margin-bottom: 6px;
}
.day-events {
font-size: 10px;
line-height: 1.5;
}
.day-event {
padding: 3px 5px;
margin-bottom: 3px;
border-radius: 6px;
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
transition: all 0.2s ease;
}
.light-theme .day-event {
background: linear-gradient(135deg, rgba(77, 166, 255, 0.25) 0%, rgba(77, 166, 255, 0.15) 100%);
color: #1a5490;
}
.dark-theme .day-event {
background: linear-gradient(135deg, rgba(77, 166, 255, 0.35) 0%, rgba(77, 166, 255, 0.25) 100%);
}
.day-event.more-indicator {
font-weight: 600;
text-align: center;
opacity: 0.8;
}
.light-theme .day-event.more-indicator {
background: rgba(77, 166, 255, 0.15);
}
.dark-theme .day-event.more-indicator {
background: rgba(77, 166, 255, 0.2);
}
.tasks-section {
border-radius: 20px;
padding: 24px;
box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}
.light-theme .tasks-section {
background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
border: 1px solid rgba(0,0,0,0.08);
}
.dark-theme .tasks-section {
background: linear-gradient(135deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.05) 100%);
border: 1px solid rgba(255,255,255,0.1);
}
.tasks-section h2 {
font-size: 22px;
margin-bottom: 20px;
opacity: 0.9;
padding-bottom: 12px;
font-weight: 600;
}
.light-theme .tasks-section h2 {
border-bottom: 1px solid rgba(0,0,0,0.1);
}
.dark-theme .tasks-section h2 {
border-bottom: 1px solid rgba(255,255,255,0.1);
}
.kanban-board {
display: flex;
gap: 20px;
overflow-x: auto;
padding-bottom: 10px;
}
.kanban-column {
min-width: 300px;
flex: 1;
border-radius: 16px;
padding: 16px;
min-height: 200px;
transition: all 0.3s ease;
}
.light-theme .kanban-column {
background: rgba(0,0,0,0.02);
}
.dark-theme .kanban-column {
background: rgba(255,255,255,0.03);
}
.light-theme .kanban-column.drag-over {
background: rgba(77, 166, 255, 0.15);
border: 2px dashed #4da6ff;
}
.dark-theme .kanban-column.drag-over {
background: rgba(77, 166, 255, 0.2);
border: 2px dashed #4da6ff;
}
.kanban-column h3 {
font-size: 16px;
margin-bottom: 16px;
opacity: 0.9;
color: #4da6ff;
font-weight: 600;
}
.task-item {
border-radius: 12px;
padding: 14px;
margin-bottom: 10px;
font-size: 14px;
border-left: 3px solid #4da6ff;
cursor: grab;
user-select: none;
display: flex;
align-items: flex-start;
gap: 12px;
transition: all 0.2s ease;
}
.light-theme .task-item {
background: linear-gradient(135deg, #ffffff 0%, #fafafa 100%);
box-shadow: 0 2px 4px rgba(0,0,0,0.08);
}
.dark-theme .task-item {
background: linear-gradient(135deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.05) 100%);
}
.light-theme .task-item:hover {
box-shadow: 0 4px 12px rgba(0,0,0,0.15);
transform: translateY(-2px);
}
.dark-theme .task-item:hover {
background: linear-gradient(135deg, rgba(255,255,255,0.12) 0%, rgba(255,255,255,0.08) 100%);
transform: translateY(-2px);
}
.task-item:active {
cursor: grabbing;
}
.task-item.dragging {
opacity: 0.5;
}
.task-item.completing {
opacity: 0.3;
text-decoration: line-through;
}
.task-checkbox {
width: 20px;
height: 20px;
border-radius: 6px;
flex-shrink: 0;
margin-top: 1px;
cursor: pointer;
transition: all 0.2s ease;
}
.light-theme .task-checkbox {
border: 2px solid rgba(0,0,0,0.3);
}
.dark-theme .task-checkbox {
border: 2px solid rgba(255,255,255,0.4);
}
.task-checkbox:hover {
border-color: #4da6ff;
background: rgba(77, 166, 255, 0.15);
transform: scale(1.1);
}
.task-text {
flex: 1;
line-height: 1.5;
}
@media (orientation: portrait) {
.header { grid-template-columns: 1fr; }
.photo-section { max-height: 350px; }
}
</style>
</head>
<body>
<div class="container">
<div class="header">
<div class="time-section">
<div class="time" id="time">00:00:00</div>
<div class="date" id="date">Loading...</div>
</div>
<div class="photo-section">
<div class="photo-frame" id="photoFrame">
<div class="photo-placeholder">
üì∑
<div class="photo-error" id="photoError"></div>
</div>
</div>
</div>
<div class="weather-card">
<h2>üå§Ô∏è Weather</h2>
<div class="weather-current">
<div class="weather-icon" id="weatherIcon">‚òÄÔ∏è</div>
<div class="temp-section">
<div class="temp" id="temp">24¬∞C</div>
<div class="feels-like" id="feelsLike">Feels like 24¬∞C</div>
</div>
</div>
<div class="weather-details" id="weatherDetails">Loading...</div>
<div class="sun-times">
<div class="sun-time"><span>üåÖ</span><span id="sunrise">--:--</span></div>
<div class="sun-time"><span>üåá</span><span id="sunset">--:--</span></div>
</div>
<div class="forecast" id="forecast">
<div class="forecast-day">
<div class="day">Loading...</div>
</div>
</div>
</div>
</div>
<div class="calendar">
<h2 id="calendarHeader">üìÖ January 2026</h2>
<div id="calendarEvents">
<div>Loading calendar...</div>
</div>
</div>
<div class="tasks-section">
<h2>‚úÖ Tasks</h2>
<div class="kanban-board" id="kanbanBoard">
<div class="kanban-column">
<h3>Loading...</h3>
</div>
</div>
</div>
</div>
<script>
let currentAccessToken = CONFIG.GOOGLE_TASKS.ACCESS_TOKEN;
let photosAccessToken = CONFIG.GOOGLE_PHOTOS ? CONFIG.GOOGLE_PHOTOS.ACCESS_TOKEN : null;
let taskListsData = {};
let photoUrls = [];
let currentPhotoIndex = 0;

function getCompassDirection(degrees) {
const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
const index = Math.round(degrees / 22.5) % 16;
return directions[index];
}

function updateTheme() {
const now = new Date();
const hour = now.getHours();
// Light theme: 6am to 6pm, Dark theme: 6pm to 6am
const isDay = hour >= 6 && hour < 18;
document.body.className = isDay ? 'light-theme' : 'dark-theme';
}

function updateTime() {
const now = new Date();
document.getElementById('time').textContent = now.toLocaleTimeString('en-AU', {
hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true
});
document.getElementById('date').textContent = now.toLocaleDateString('en-AU', {
weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
});
updateTheme();
}

function getSunTimes(lat, lon, date) {
// Simplified sunrise/sunset calculation
const J = Math.floor((date.getTime() / 86400000) + 2440587.5);
const n = J - 2451545 + 0.0008;
const Jstar = n - (lon / 360);
const M = (357.5291 + 0.98560028 * Jstar) % 360;
const C = 1.9148 * Math.sin(M * Math.PI / 180) + 0.0200 * Math.sin(2 * M * Math.PI / 180);
const lambda = (M + C + 180 + 102.9372) % 360;
const Jtransit = 2451545 + Jstar + 0.0053 * Math.sin(M * Math.PI / 180) - 0.0069 * Math.sin(2 * lambda * Math.PI / 180);
const delta = Math.asin(Math.sin(lambda * Math.PI / 180) * Math.sin(23.44 * Math.PI / 180));
const omega = Math.acos((Math.sin(-0.83 * Math.PI / 180) - Math.sin(lat * Math.PI / 180) * Math.sin(delta)) / (Math.cos(lat * Math.PI / 180) * Math.cos(delta)));
const Jset = Jtransit + (omega * 180 / Math.PI) / 360;
const Jrise = Jtransit - (omega * 180 / Math.PI) / 360;
const sunrise = new Date((Jrise - 2440587.5) * 86400000);
const sunset = new Date((Jset - 2440587.5) * 86400000);
return { sunrise, sunset };
}

async function loadPhotos() {
if (typeof CONFIG === 'undefined' || !CONFIG.GOOGLE_PHOTOS) {
console.log('Google Photos not configured');
document.getElementById('photoError').textContent = 'Not configured';
return;
}
try {
console.log('Testing Photos API - loading recent photos');
const url = 'https://photoslibrary.googleapis.com/v1/mediaItems:search';
const response = await fetch(url, {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + photosAccessToken,
'Content-Type': 'application/json'
},
body: JSON.stringify({
pageSize: 20
})
});

console.log('Photos API response status:', response.status);

if (response.status === 401) {
console.error('Photos auth failed - token expired or invalid');
document.getElementById('photoError').textContent = 'Auth failed';
return;
}

if (response.status === 403) {
console.error('Photos access forbidden');
document.getElementById('photoError').textContent = 'API access denied';
return;
}

const data = await response.json();
console.log('Photos API response:', data);

if (data.mediaItems) {
photoUrls = data.mediaItems
.filter(item => item.mimeType && item.mimeType.startsWith('image/'))
.map(item => item.baseUrl);
console.log('Loaded ' + photoUrls.length + ' photos');
if (photoUrls.length > 0) {
showNextPhoto();
} else {
document.getElementById('photoError').textContent = 'No photos found';
}
} else if (data.error) {
console.error('Photos API error:', data.error);
document.getElementById('photoError').textContent = data.error.message;
}
} catch (error) {
console.error('Photo fetch error:', error);
document.getElementById('photoError').textContent = 'Error loading';
}
}

function showNextPhoto() {
if (photoUrls.length === 0) return;

const photoFrame = document.getElementById('photoFrame');
const currentImg = photoFrame.querySelector('.photo-image.active');
const newImg = document.createElement('img');
newImg.className = 'photo-image';
newImg.src = photoUrls[currentPhotoIndex] + '=w1600-h900';
newImg.alt = 'Family photo';

newImg.onload = () => {
const placeholder = photoFrame.querySelector('.photo-placeholder');
if (placeholder) {
placeholder.remove();
}

photoFrame.appendChild(newImg);
setTimeout(() => {
newImg.classList.add('active');
}, 50);

setTimeout(() => {
if (currentImg) {
currentImg.remove();
}
}, 1500);
};

newImg.onerror = () => {
console.error('Failed to load photo:', photoUrls[currentPhotoIndex]);
};

currentPhotoIndex = (currentPhotoIndex + 1) % photoUrls.length;
}

async function updateWeather() {
if (typeof CONFIG === 'undefined') return;
try {
const url = 'https://api.weather.com/v2/pws/observations/current?stationId=' + CONFIG.WEATHER_UNDERGROUND.STATION_ID + '&format=json&units=m&apiKey=' + CONFIG.WEATHER_UNDERGROUND.API_KEY;
const response = await fetch(url);
const data = await response.json();
const obs = data.observations[0];

const temp = Math.round(obs.metric.temp);
const feelsLike = Math.round(obs.metric.heatIndex || obs.metric.windChill || temp);
document.getElementById('temp').textContent = temp + '¬∞C';
document.getElementById('feelsLike').textContent = 'Feels like ' + feelsLike + '¬∞C';
const windDir = getCompassDirection(obs.winddir);
document.getElementById('weatherDetails').innerHTML =
'Humidity: ' + obs.humidity + '%<br>' +
'Wind: ' + Math.round(obs.metric.windSpeed) + ' km/h ' + windDir + '<br>' +
'Rain today: ' + obs.metric.precipTotal + 'mm';

// Calculate sunrise/sunset
const sunTimes = getSunTimes(CONFIG.OPENWEATHERMAP.LAT, CONFIG.OPENWEATHERMAP.LON, new Date());
document.getElementById('sunrise').textContent = sunTimes.sunrise.toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit', hour12: true });
document.getElementById('sunset').textContent = sunTimes.sunset.toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit', hour12: true });

let icon = '‚òÄÔ∏è';
if (obs.solarRadiation < 200) icon = 'üåô';
else if (obs.humidity > 80) icon = 'üåßÔ∏è';
else if (obs.humidity > 60) icon = '‚õÖ';
document.getElementById('weatherIcon').textContent = icon;
} catch (error) {
console.error('Weather fetch error:', error);
}
}

async function updateForecast() {
if (typeof CONFIG === 'undefined' || !CONFIG.OPENWEATHERMAP) return;
try {
const url = 'https://api.openweathermap.org/data/2.5/forecast?lat=' + CONFIG.OPENWEATHERMAP.LAT + '&lon=' + CONFIG.OPENWEATHERMAP.LON + '&appid=' + CONFIG.OPENWEATHERMAP.API_KEY + '&units=metric';
const response = await fetch(url);
const data = await response.json();

const dailyForecasts = {};
data.list.forEach(item => {
const date = new Date(item.dt * 1000);
const dayKey = date.toLocaleDateString('en-AU', { weekday: 'short' });
const hour = date.getHours();

if (!dailyForecasts[dayKey] || Math.abs(hour - 12) < Math.abs(dailyForecasts[dayKey].hour - 12)) {
dailyForecasts[dayKey] = {
day: dayKey,
temp: Math.round(item.main.temp),
rain: item.rain ? item.rain['3h'] || 0 : 0,
pop: Math.round(item.pop * 100),
icon: item.weather[0].main,
hour: hour
};
}
});

const forecasts = Object.values(dailyForecasts).slice(0, 4);

const forecastDiv = document.getElementById('forecast');
forecastDiv.innerHTML = forecasts.map(f => {
let weatherIcon = '‚òÄÔ∏è';
if (f.icon === 'Rain') weatherIcon = 'üåßÔ∏è';
else if (f.icon === 'Clouds') weatherIcon = '‚òÅÔ∏è';
else if (f.icon === 'Clear') weatherIcon = '‚òÄÔ∏è';
else if (f.icon === 'Snow') weatherIcon = '‚ùÑÔ∏è';
else if (f.icon === 'Thunderstorm') weatherIcon = '‚õàÔ∏è';

return '<div class="forecast-day">' +
'<div class="day">' + f.day + '</div>' +
'<div class="icon">' + weatherIcon + '</div>' +
'<div class="temp">' + f.temp + '¬∞C</div>' +
'<div class="rain">' + f.pop + '% | ' + f.rain.toFixed(1) + 'mm</div>' +
'</div>';
}).join('');

} catch (error) {
console.error('Forecast fetch error:', error);
}
}

async function updateCalendar() {
if (typeof CONFIG === 'undefined' || !CONFIG.GOOGLE_CALENDAR) return;
try {
const now = new Date();
const year = now.getFullYear();
const month = now.getMonth();

// Get start of current week (Sunday)
const currentDay = now.getDate();
const currentDayOfWeek = now.getDay();
const startOfWeek = new Date(year, month, currentDay - currentDayOfWeek);

// End is 4 weeks (28 days) from start of week
const endOfPeriod = new Date(startOfWeek);
endOfPeriod.setDate(endOfPeriod.getDate() + 27); // 27 days ahead = 4 weeks total

// Update header to show date range
const startFormatted = startOfWeek.toLocaleDateString('en-AU', { day: 'numeric', month: 'short' });
const endFormatted = endOfPeriod.toLocaleDateString('en-AU', { day: 'numeric', month: 'short', year: 'numeric' });
document.getElementById('calendarHeader').textContent = 'üìÖ ' + startFormatted + ' ‚Äì ' + endFormatted;

const timeMin = startOfWeek.toISOString();
const timeMax = new Date(endOfPeriod.getFullYear(), endOfPeriod.getMonth(), endOfPeriod.getDate(), 23, 59, 59).toISOString();

const allEvents = [];
for (const calendarId of CONFIG.GOOGLE_CALENDAR.CALENDAR_IDS) {
try {
const url = 'https://www.googleapis.com/calendar/v3/calendars/' + encodeURIComponent(calendarId) + '/events?key=' + CONFIG.GOOGLE_CALENDAR.API_KEY + '&timeMin=' + timeMin + '&timeMax=' + timeMax + '&singleEvents=true&orderBy=startTime&maxResults=100';
const response = await fetch(url);
const data = await response.json();

if (data.items) {
allEvents.push(...data.items);
}
} catch (err) {
console.error('Error fetching calendar ' + calendarId + ':', err);
}
}

const eventsByDate = {};
allEvents.forEach(event => {
const start = event.start.dateTime || event.start.date;
const date = new Date(start);
const dateKey = date.getFullYear() + '-' + date.getMonth() + '-' + date.getDate();

if (!eventsByDate[dateKey]) {
eventsByDate[dateKey] = [];
}

eventsByDate[dateKey].push({
title: event.summary || 'Untitled',
time: event.start.dateTime ? date.toLocaleTimeString('en-AU', { hour: 'numeric', minute: '2-digit', hour12: true }) : null
});
});

const calendarDiv = document.getElementById('calendarEvents');
let html = '<div class="calendar-grid">';

const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
dayNames.forEach(day => {
html += '<div class="calendar-header">' + day + '</div>';
});

// Show exactly 4 weeks (28 days) starting from start of current week
for (let dayOffset = 0; dayOffset < 28; dayOffset++) {
const currentDate = new Date(startOfWeek);
currentDate.setDate(startOfWeek.getDate() + dayOffset);

const isToday = currentDate.toDateString() === now.toDateString();
const isPast = currentDate < now && !isToday;
const dateKey = currentDate.getFullYear() + '-' + currentDate.getMonth() + '-' + currentDate.getDate();
const events = eventsByDate[dateKey] || [];

let classes = 'calendar-day';
if (isToday) classes += ' today';
if (isPast) classes += ' past';

html += '<div class="' + classes + '">';
html += '<div class="day-number">' + currentDate.getDate() + '</div>';
html += '<div class="day-events">';

events.slice(0, 3).forEach(event => {
const timeStr = event.time ? event.time + ' ' : '';
html += '<div class="day-event">' + timeStr + event.title + '</div>';
});

if (events.length > 3) {
html += '<div class="day-event more-indicator">+' + (events.length - 3) + ' more</div>';
}

html += '</div></div>';
}

html += '</div>';
calendarDiv.innerHTML = html;

} catch (error) {
console.error('Calendar fetch error:', error);
document.getElementById('calendarEvents').innerHTML = '<div>Error loading calendar</div>';
}
}

async function refreshAccessToken() {
try {
const response = await fetch('https://oauth2.googleapis.com/token', {
method: 'POST',
headers: {
'Content-Type': 'application/x-www-form-urlencoded',
},
body: new URLSearchParams({
client_id: CONFIG.GOOGLE_TASKS.CLIENT_ID,
client_secret: CONFIG.GOOGLE_TASKS.CLIENT_SECRET,
refresh_token: CONFIG.GOOGLE_TASKS.REFRESH_TOKEN,
grant_type: 'refresh_token'
})
});

const data = await response.json();
if (data.access_token) {
currentAccessToken = data.access_token;
photosAccessToken = data.access_token;
return true;
}
return false;
} catch (error) {
console.error('Token refresh error:', error);
return false;
}
}

async function completeTask(taskId, listId, taskElement) {
try {
taskElement.classList.add('completing');

const completeUrl = 'https://www.googleapis.com/tasks/v1/lists/' + listId + '/tasks/' + taskId;
const response = await fetch(completeUrl, {
method: 'PATCH',
headers: {
'Authorization': 'Bearer ' + currentAccessToken,
'Content-Type': 'application/json'
},
body: JSON.stringify({
status: 'completed'
})
});

if (response.status === 401) {
await refreshAccessToken();
return await completeTask(taskId, listId, taskElement);
}

if (response.ok) {
setTimeout(() => {
taskElement.remove();
}, 300);
}
} catch (error) {
console.error('Complete task error:', error);
taskElement.classList.remove('completing');
}
}

async function moveTask(taskId, fromListId, toListId) {
try {
const taskData = taskListsData[fromListId].tasks.find(t => t.id === taskId);

const deleteUrl = 'https://www.googleapis.com/tasks/v1/lists/' + fromListId + '/tasks/' + taskId;
const deleteResponse = await fetch(deleteUrl, {
method: 'DELETE',
headers: {
'Authorization': 'Bearer ' + currentAccessToken
}
});

if (deleteResponse.status === 401) {
await refreshAccessToken();
return await moveTask(taskId, fromListId, toListId);
}

const createUrl = 'https://www.googleapis.com/tasks/v1/lists/' + toListId + '/tasks';
const createResponse = await fetch(createUrl, {
method: 'POST',
headers: {
'Authorization': 'Bearer ' + currentAccessToken,
'Content-Type': 'application/json'
},
body: JSON.stringify({
title: taskData.title,
notes: taskData.notes || ''
})
});

if (createResponse.ok) {
await updateTasks();
}
} catch (error) {
console.error('Move task error:', error);
}
}

async function updateTasks() {
if (typeof CONFIG === 'undefined' || !CONFIG.GOOGLE_TASKS) return;
try {
const listsUrl = 'https://www.googleapis.com/tasks/v1/users/@me/lists';
const listsResponse = await fetch(listsUrl, {
headers: {
'Authorization': 'Bearer ' + currentAccessToken
}
});

if (listsResponse.status === 401) {
const refreshed = await refreshAccessToken();
if (refreshed) {
return await updateTasks();
} else {
throw new Error('Token refresh failed');
}
}

const listsData = await listsResponse.json();

if (!listsData.items) {
document.getElementById('kanbanBoard').innerHTML = '<div class="kanban-column"><h3>No task lists found</h3></div>';
return;
}

const wantedLists = listsData.items.filter(list =>
CONFIG.GOOGLE_TASKS.TASK_LISTS.includes(list.title)
);

taskListsData = {};
const kanbanHTML = [];

for (const list of wantedLists) {
try {
const tasksUrl = 'https://www.googleapis.com/tasks/v1/lists/' + list.id + '/tasks?maxResults=20';
const tasksResponse = await fetch(tasksUrl, {
headers: {
'Authorization': 'Bearer ' + currentAccessToken
}
});
const tasksData = await tasksResponse.json();

const tasks = tasksData.items || [];
const incompleteTasks = tasks.filter(task => task.status !== 'completed');

taskListsData[list.id] = { title: list.title, tasks: incompleteTasks };

let tasksHTML = '';
if (incompleteTasks.length === 0) {
tasksHTML = '<div style="opacity: 0.5; font-size: 13px;">No tasks</div>';
} else {
tasksHTML = incompleteTasks.map(task => {
return '<div class="task-item" draggable="true" data-task-id="' + task.id + '" data-list-id="' + list.id + '">' +
'<div class="task-checkbox" data-task-id="' + task.id + '" data-list-id="' + list.id + '"></div>' +
'<div class="task-text">' + task.title + '</div>' +
'</div>';
}).join('');
}

kanbanHTML.push(
'<div class="kanban-column" data-list-id="' + list.id + '">' +
'<h3>' + list.title + '</h3>' +
tasksHTML +
'</div>'
);
} catch (err) {
console.error('Error fetching tasks for ' + list.title + ':', err);
}
}

document.getElementById('kanbanBoard').innerHTML = kanbanHTML.join('');
setupDragAndDrop();
setupCheckboxes();

} catch (error) {
console.error('Tasks fetch error:', error);
document.getElementById('kanbanBoard').innerHTML = '<div class="kanban-column"><h3>Error loading tasks</h3></div>';
}
}

function setupCheckboxes() {
const checkboxes = document.querySelectorAll('.task-checkbox');
checkboxes.forEach(checkbox => {
checkbox.addEventListener('click', (e) => {
e.stopPropagation();
const taskId = checkbox.dataset.taskId;
const listId = checkbox.dataset.listId;
const taskElement = checkbox.closest('.task-item');
completeTask(taskId, listId, taskElement);
});
});
}

function setupDragAndDrop() {
const taskItems = document.querySelectorAll('.task-item');
const columns = document.querySelectorAll('.kanban-column');

taskItems.forEach(task => {
task.addEventListener('dragstart', (e) => {
task.classList.add('dragging');
e.dataTransfer.effectAllowed = 'move';
e.dataTransfer.setData('text/plain', task.dataset.taskId);
e.dataTransfer.setData('fromList', task.dataset.listId);
});

task.addEventListener('dragend', (e) => {
task.classList.remove('dragging');
});
});

columns.forEach(column => {
column.addEventListener('dragover', (e) => {
e.preventDefault();
column.classList.add('drag-over');
});

column.addEventListener('dragleave', (e) => {
column.classList.remove('drag-over');
});

column.addEventListener('drop', async (e) => {
e.preventDefault();
column.classList.remove('drag-over');

const taskId = e.dataTransfer.getData('text/plain');
const fromListId = e.dataTransfer.getData('fromList');
const toListId = column.dataset.listId;

if (fromListId !== toListId) {
await moveTask(taskId, fromListId, toListId);
}
});
});
}

// Initialize
updateTime();
setInterval(updateTime, 1000);

updateWeather();
updateForecast();
setInterval(updateWeather, 300000);
setInterval(updateForecast, 300000);

updateCalendar();
setInterval(updateCalendar, 300000);

updateTasks();
setInterval(updateTasks, 300000);

// Load and cycle photos
loadPhotos();
setInterval(showNextPhoto, 45000);

setTimeout(() => location.reload(), 60000);
</script>
</body>
</html>
